"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BaseContract = exports.HarmonyContract = exports.ContractError = void 0;
const contract_1 = require("@harmony-js/contract");
const utils_1 = require("@harmony-js/utils");
const constants_1 = require("../constants");
class ContractError extends Error {
    constructor(message, type) {
        super(message);
        this.name = ContractError.name;
        this.type = type;
        Error.captureStackTrace(this, this.constructor);
    }
}
exports.ContractError = ContractError;
class HarmonyContract extends contract_1.Contract {
    constructor(abi, address, provider, options) {
        super(abi, address, options, provider);
        this.wallet = provider;
    }
}
exports.HarmonyContract = HarmonyContract;
class BaseContract {
    constructor(address, abi, provider, options) {
        this._contract = new HarmonyContract(abi, address, provider, options);
        this._provider = provider;
        this.address = this._contract.address;
        this.messenger = this._provider.messenger;
    }
    sanitizeAddress(address) {
        return address.toLowerCase();
    }
    estimateGas(method, args = [], options = {
        gasPrice: constants_1.DEFAULT_GAS_PRICE,
    }) {
        return __awaiter(this, void 0, void 0, function* () {
            let gasLimit = options.gasLimit;
            if (!gasLimit) {
                const hexValue = yield this._contract.methods[method](...args).estimateGas({
                    gasPrice: (0, utils_1.numberToHex)(options.gasPrice),
                });
                gasLimit = (0, utils_1.hexToNumber)(hexValue);
            }
            return Object.assign(Object.assign({}, options), { gasLimit });
        });
    }
    call(method, args = [], txOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            const options = yield this.estimateGas(method, args, txOptions);
            return this._contract.methods[method](...args).call(options);
        });
    }
    send(method, args = [], txOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            const options = yield this.estimateGas(method, args, txOptions);
            const response = yield this._contract.methods[method](...args).send(options);
            if (!response.transaction) {
                throw new ContractError('Invalid transaction response', method);
            }
            return response.transaction;
        });
    }
    setSignerByPrivateKey(privateKey) {
        const account = this._contract.wallet.addByPrivateKey(privateKey);
        if (account.address) {
            this._contract.wallet.setSigner(account.address);
        }
        return account;
    }
    setSignerByMnemonic(mnemonic, index = 0) {
        const account = this._contract.wallet.addByMnemonic(mnemonic, index);
        if (account.address) {
            this._contract.wallet.setSigner(account.address);
        }
        return account;
    }
    setSignerByKey(key) {
        this._contract.connect(key);
    }
}
exports.BaseContract = BaseContract;
//# sourceMappingURL=baseContract.js.map