"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.HDKey = void 0;
const account_1 = require("@harmony-js/account");
const transaction_1 = require("@harmony-js/transaction");
const utils_1 = require("@harmony-js/utils");
const key_1 = require("./key");
class HDKey extends key_1.Key {
    constructor(url, options, chainId, chainType) {
        super(url, chainId, chainType);
        const { mnemonic = account_1.Wallet.generateMnemonic(), index = 0, numberOfAddresses = 1, shardId = 0, gasLimit = '1000000', gasPrice = '2000000000', } = options;
        this.hdNode = new account_1.HDNode(this.messenger.provider.url, mnemonic, index, numberOfAddresses, shardId, utils_1.ChainType.Harmony, chainId, gasLimit, gasPrice);
    }
    signTransaction(transaction) {
        return __awaiter(this, void 0, void 0, function* () {
            const rawTransaction = yield this.hdNode.signTransaction(transaction.txParams);
            const params = (0, transaction_1.recover)(rawTransaction);
            const tx = new transaction_1.Transaction({}, this.messenger);
            tx.setParams(params);
            return tx;
        });
    }
    setSigner(address) {
        this.hdNode.setSigner(address);
    }
    addByPrivateKey(privateKey) {
        this.hdNode.addByPrivateKey(privateKey);
        return account_1.Account.add(privateKey);
    }
    getAccount(address) {
        const addresses = this.hdNode.getAccounts();
        if (addresses.includes(address)) {
            return account_1.Account.add(this.hdNode.getPrivateKey(address));
        }
        return;
    }
    setMessenger(messenger) {
        super.setMessenger(messenger);
        this.hdNode.setProvider(this.messenger.provider);
    }
    getAddress(idx) {
        return this.hdNode.getAddress(idx);
    }
    getAddresses() {
        return this.hdNode.getAddresses();
    }
}
exports.HDKey = HDKey;
//# sourceMappingURL=hd-key.js.map